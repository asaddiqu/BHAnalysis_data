// -*- C++ -*-
//
// Package:    BHAnalyzerTLBSM
// Class:      BHAnalyzerTLBSM
// 
/**\class BHAnalyzerTLBSM BHAnalyzerTLBSM.cc AnalysisCodeTLBSM/BHAnalyzerTLBSM/src/BHAnalyzerTLBSM.cc

 Description: [one line class summary]

 Implementation:
     [Notes on implementation]
*/
//
// Original Author:  Alexey Ferapontov,8 R-021,+41227676332,
//         Created:  Mon Apr 2 11:25:01 CEST 2010
// $Id: BHAnalyzerTLBSM.cc,v 1.1 2012/04/03 03:08:26 aferapon Exp $
//
//


// system include files
#include <memory>

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"
#include "FWCore/Utilities/interface/InputTag.h"

#include "DataFormats/PatCandidates/interface/Muon.h"
#include "DataFormats/PatCandidates/interface/Jet.h"
#include "DataFormats/PatCandidates/interface/Electron.h"
#include "DataFormats/PatCandidates/interface/Tau.h"
#include "DataFormats/PatCandidates/interface/Photon.h"
#include "DataFormats/PatCandidates/interface/MET.h"

#include "DataFormats/Common/interface/View.h"
#include "DataFormats/Math/interface/LorentzVector.h"
#include "DataFormats/JetReco/interface/JetID.h"
#include "DataFormats/TrackReco/interface/Track.h"

#include "FWCore/Common/interface/TriggerNames.h"
#include "DataFormats/Common/interface/TriggerResults.h"
#include "DataFormats/HLTReco/interface/TriggerObject.h"
#include "DataFormats/HLTReco/interface/TriggerEvent.h"
#include "FWCore/Framework/interface/TriggerNamesService.h"

// ECAL spike cleaning - Swiss cross
#include "Geometry/CaloTopology/interface/CaloTopology.h"
#include "Geometry/CaloEventSetup/interface/CaloTopologyRecord.h"
#include "DataFormats/PatCandidates/interface/Photon.h"
#include "RecoEcal/EgammaCoreTools/interface/EcalClusterTools.h"
#include "FWCore/Framework/interface/ESHandle.h"

#include "DataFormats/DetId/interface/DetId.h"
#include "DataFormats/EcalDetId/interface/EcalSubdetector.h"
#include "DataFormats/EcalRecHit/interface/EcalRecHitCollections.h"
#include "RecoLocalCalo/EcalRecAlgos/interface/EcalSeverityLevelAlgo.h"
#include "RecoEcal/EgammaCoreTools/interface/EcalClusterLazyTools.h"

#include "DataFormats/Common/interface/ValueMap.h"

#include <map>
#include <vector>
#include <string>
#include <algorithm>
#include "TH1F.h"
#include "TH2F.h"
#include "TMath.h"
#include "TTree.h"
#include "TLorentzVector.h"
//
// class declaration
//

using namespace edm;
using namespace std;

class BHAnalyzerTLBSM : public edm::EDAnalyzer {
   public:
      explicit BHAnalyzerTLBSM(const edm::ParameterSet&);
      ~BHAnalyzerTLBSM();


   private:
     virtual void beginJob();
      virtual void analyze(const edm::Event&, const edm::EventSetup&);
      virtual void endJob();

      // ----------member data ---------------------------
      edm::Service<TFileService> fs_;  
      bool jetid(const edm::View<pat::Jet>::const_iterator &jet_iter); 
      bool elecId(const edm::View<pat::Electron>::const_iterator & elec_iter, const reco::Vertex & vertex_); 
      bool muonId(const edm::View<pat::Muon>::const_iterator & muon_iter, const reco::Vertex & vertex_); 
      bool photonId(const edm::View<pat::Photon>::const_iterator & ph_iter, const reco::Vertex & vertex_); 

      void createHistogram(const std::string& folderName);
      bool check(std::string process, std::string pCheck);
      void init(const edm::TriggerResults &, const edm::TriggerNames & HLTNames);

      std::map<std::string, unsigned int> prescales;
      std::map<std::string, unsigned int> prescale_counter; 
      std::map<std::string, unsigned int> trigger_indices;

      edm::InputTag eleLabel_;
      edm::InputTag eleID_loose;
      edm::InputTag eleID_medium;
      edm::InputTag eleID_tight;
      edm::InputTag muoLabel_;
      edm::InputTag jetLabel_;
      edm::InputTag tauLabel_;
      edm::InputTag metLabel_;
      edm::InputTag phoLabel_;
      edm::InputTag rechitBLabel_;
      edm::InputTag rechitELabel_;
      edm::InputTag pvSrc_;
      edm::InputTag triggerLabel_;
      edm::InputTag rhoLabel_;
      
      // tools for clusters

      // std::auto_ptr<EcalClusterLazyTools> lazyTools_;
              
      bool isMCBH;
      bool DEBUG_;

      edm::InputTag ebRecHitsLabel_;
      edm::InputTag eeRecHitsLabel_;

      edm::EDGetTokenT<EcalRecHitCollection> ebRecHitsToken_;
      edm::EDGetTokenT<EcalRecHitCollection> eeRecHitsToken_;

      reco::TrackBase::TrackQuality _trackQuality;
 
      std::vector< std::map<std::string,TH1*> > histos_; 
      std::vector<std::string> cutNames_;
      //TH1F* h_norm;
      
      edm::EDGetTokenT<edm::ValueMap<float> > full5x5SigmaIEtaIEtaMapToken_; 
      edm::EDGetTokenT<edm::ValueMap<float> > phoChargedIsolationToken_; 
      edm::EDGetTokenT<edm::ValueMap<float> > phoNeutralHadronIsolationToken_; 
      edm::EDGetTokenT<edm::ValueMap<float> > phoPhotonIsolationToken_; 

      edm::EDGetTokenT<edm::ValueMap<bool> > electronVetoIdMapToken_;
      edm::EDGetTokenT<edm::ValueMap<bool> > electronMediumIdMapToken_;

      //TTree
      TTree* tree;
      float JetE[25];
      float JetPx[25];
      float JetPy[25];
      float JetPz[25];
      float JetPt[25];
      float JetEta[25];
      float JetPhi[25];      
      int   JetNumOfDaughters[25];      
      float JetNeutralHadEnergyFrac[25]; 
      float JetChargeHadEnergyFrac[25];     
      float JetNeutralEmEnergyFrac[25];      
      float JetChargeEmEnergyFrac[25];      
      float JetChargeMult[25]; 
      // JetEMF was made from emEnergyFraction()--this does not work with our PAT jets
      // float JetEMF[25];
      
      float EleE[25];
      float ElePx[25];
      float ElePy[25];
      float ElePz[25];
      float ElePt[25];
      float EleEta[25];
      float ElePhi[25]; 
      float EleSupEta[25];     
      float EleRelIsoR03DB[25];      
      float EleAbsDxy[25];      
      float EleNumOfHits[25];      
      float EleChargeHadIso[25];
      float EleNeutralHadIso[25];
      float ElePhotonIso[25];
      float EleUsrIso[25];
      float EleEt[25];
      float EleVtx[25];
      int   EleVetoId[25];      
      int   EleMediumId[25];      
      int   ElePassConvVeto[25];


      float PhE[25];
      float PhPx[25];
      float PhPy[25];
      float PhPz[25];
      float PhPt[25];
      float PhEta[25];
      float PhSupEta[25];
      float PhPhi[25];
      float PhSwissCross[25];      
      float PhHadoverEM[25];
      float PhHasPixelSeed[25];
      float Ph5x5sigmaIetaIeta[25];
      float Phr9[25];
      
      double PhIsoChargedHadrons[25];
      double PhIsoNeutralHadrons[25];
      double PhIsoPhotons[25];
      
      double PhIsoChargedHadronsEA[25];
      double PhIsoNeutralHadronsEA[25];
      double PhIsoPhotonsEA[25];
      
      float MuE[25];
      float MuPx[25];
      float MuPy[25];
      float MuPz[25];
      float MuPt[25];
      float MuEta[25];
      float MuPhi[25];    
      float MuAbsDxy[25];  
      int   MuIsGlobal[25];  
      int   MuIsPF[25];  
      float MuNormChi2[25];  
      int   MuTrkLayers[25];  
      int   MuValidHits[25];  
      float MuDz[25];  
      int   MuPixelHits[25];  
      int   MuMatchedStations[25];  
      float MuRelIsoR04DB[25];  
      float MuRelIsoR03DB[25];  
      
      float ST;
      float mBH;
      float Met;
      float MetE;
      float MetPx;
      float MetPy;
      float MetPz;
      float MetPt;      
      float MetPhi;      
      float Sphericity;
      float JetArr[4];      
      float EleArr[4];
      float MuArr[4];      
      float PhArr[4];
      int NPV;
      int NTracks;
      int NJets;
      int NElectrons;
      int NPhotons;      
      int NMuons; 
      bool NoScrap;     
      
      int Multiplicity; 
      bool isLeptonPhoton;
      bool isEleChannel;
      bool isMuChannel;
      bool isPhChannel;

      //
      float ResJetEta;
      float ResJetPhi;      
      float ResJetM;
      float ResJetPt;
      float ResEleEta;
      float ResElePhi;      
      float ResEleM;
      float ResElePt;      
      float ResPhEta;
      float ResPhPhi;      
      float ResPhM;
      float ResPhPt;
      float ResMuEta;
      float ResMuPhi;      
      float ResMuM;
      float ResMuPt;
      float ResLepEta;
      float ResLepPhi;      
      float ResLepM;
      float ResLepPt;
      float ResObjEta;
      float ResObjPhi;      
      float ResObjM;
      float ResObjPt;
      
      int runno;
      int evtno;
      int lumiblock;
      int isRealData;
      float muon_d0;
                                                                                      
  float LeadingArr[4];    

  //HLT info (Jets and MET)
  bool firedHLT_L1Jet6U;
  bool firedHLT_L1Jet10U;
  bool firedHLT_Jet15U;
  bool firedHLT_Jet30U;
  bool firedHLT_Jet50U;
  bool firedHLT_DiJetAve15U_8E29;
  bool firedHLT_DiJetAve30U_8E29;
  bool firedHLT_MET45;
  bool firedHLT_MET100;
  bool firedHLT_HT100U;
  bool firedHLT_HT140U;
  bool firedHLT_HT140U_Eta3_v1;
  bool firedHLT_HT160U_v1;
  bool firedHLT_HT200U; 
  bool firedHLT_HT200U_v1;     
  bool firedHLT_FwdJet20U;
  bool firedHLT_QuadJet15U;
  bool firedHLT_L1MET20;
  
  double Reliso_el;
  double Reliso_mu;
  int pass_eleID_medium;      
  
  Float_t rho_;

  };

  // Effective areas for photons from Savvas's slide for phys14 PU20bx25, described here:
  // https://indico.cern.ch/event/367861/contribution/3/material/slides/0.pdf
  namespace EffectiveAreas {
  const int nEtaBins = 7;
  const float etaBinLimits[nEtaBins+1] = {0.0, 1.0, 1.479, 2.0, 2.2, 2.3, 2.4, 2.5};

  const float areaPhotons[nEtaBins] = {0.0894361, 0.0750406, 0.0422692, 0.0561305, 0.0881777, 0.114391, 0.168394};
  const float areaNeutralHadrons[nEtaBins] = {0.00491696, 0.0108215, 0.00185819, 0.0036691, 0.00619475, 0.0130409, 0.169902};
  const float areaChargedHadrons[nEtaBins] = {0.00885603, 0.00615045, 0.00861475, 0.00412423, 0.0113191, 0.00846383, 0.0038625};
  }

  // constants, enums and typedefs

  // static data member definitions

  // constructors and destructor
  BHAnalyzerTLBSM::BHAnalyzerTLBSM(const edm::ParameterSet& iConfig):
  eleLabel_(iConfig.getUntrackedParameter<edm::InputTag>("electronTag")),
  eleID_loose(iConfig.getUntrackedParameter<edm::InputTag>("electronID_loose")),
  eleID_medium(iConfig.getUntrackedParameter<edm::InputTag>("electronID_medium")),
  eleID_tight(iConfig.getUntrackedParameter<edm::InputTag>("electronID_tight")),
  muoLabel_(iConfig.getUntrackedParameter<edm::InputTag>("muonTag")),
  jetLabel_(iConfig.getUntrackedParameter<edm::InputTag>("jetTag")),
  tauLabel_(iConfig.getUntrackedParameter<edm::InputTag>("tauTag")),
  metLabel_(iConfig.getUntrackedParameter<edm::InputTag>("metTag")),
  phoLabel_(iConfig.getUntrackedParameter<edm::InputTag>("photonTag")),
  pvSrc_(iConfig.getUntrackedParameter<edm::InputTag>("primaryVertex")),
  triggerLabel_(iConfig.getUntrackedParameter<edm::InputTag>("triggerTag")),  
  rhoLabel_(iConfig.getUntrackedParameter<edm::InputTag>("rho_lable")),
  isMCBH(iConfig.getUntrackedParameter<bool>("MCLabel",false)),
  DEBUG_(iConfig.getUntrackedParameter<bool>("DEBUG",false)),
  eeRecHitsLabel_(iConfig.getUntrackedParameter<edm::InputTag>("eeRecHitTag")),
  ebRecHitsToken_(consumes<EcalRecHitCollection>(ebRecHitsLabel_)),
  eeRecHitsToken_(consumes<EcalRecHitCollection>(eeRecHitsLabel_)),
  full5x5SigmaIEtaIEtaMapToken_(consumes <edm::ValueMap<float> > (iConfig.getParameter<edm::InputTag>("full5x5SigmaIEtaIEtaMap"))),
  phoChargedIsolationToken_(consumes <edm::ValueMap<float> >(iConfig.getParameter<edm::InputTag>("phoChargedIsolation"))),
phoNeutralHadronIsolationToken_(consumes <edm::ValueMap<float> >(iConfig.getParameter<edm::InputTag>("phoNeutralHadronIsolation"))),
  phoPhotonIsolationToken_(consumes <edm::ValueMap<float> >(iConfig.getParameter<edm::InputTag>("phoPhotonIsolation"))),
  electronVetoIdMapToken_(consumes<edm::ValueMap<bool> >(iConfig.getParameter<edm::InputTag>("electronVetoIdMap"))),
  electronMediumIdMapToken_(consumes<edm::ValueMap<bool> >(iConfig.getParameter<edm::InputTag>("electronMediumIdMap")))
  {
   //now do what ever initialization is needed
  }


BHAnalyzerTLBSM::~BHAnalyzerTLBSM()
{
 
   // do anything here that needs to be done at desctruction time
   // (e.g. close files, deallocate resources etc.)

}


//
// member functions
//

// ------------ method called to for each event  ------------
void
BHAnalyzerTLBSM::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup)
{
   using namespace edm;

   runno = iEvent.id().run();
   evtno  = iEvent.id().event();
   lumiblock = iEvent.luminosityBlock();
   isRealData = iEvent.isRealData();
   
   //{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
   // first: get all objects from the event.
   //{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}
  // All PF Candidate for alternate isolation
   
   edm::Handle<double> rhoHandle;
   iEvent.getByLabel(rhoLabel_,rhoHandle);
   
   if(rhoHandle.isValid()) {
   rho_ = *(rhoHandle.product());
   //std::cout<<"rho value = "<<*(rhoHandle.product())<<std::endl;
   }
   // Get the full5x5 sieie map
   edm::Handle<edm::ValueMap<float> > full5x5SigmaIEtaIEtaMap;
   iEvent.getByToken(full5x5SigmaIEtaIEtaMapToken_, full5x5SigmaIEtaIEtaMap);

  // Get the isolation maps
  edm::Handle<edm::ValueMap<float> > phoChargedIsolationMap;
  iEvent.getByToken(phoChargedIsolationToken_, phoChargedIsolationMap);
  
  edm::Handle<edm::ValueMap<float> > phoNeutralHadronIsolationMap;
  iEvent.getByToken(phoNeutralHadronIsolationToken_, phoNeutralHadronIsolationMap);
  
  edm::Handle<edm::ValueMap<float> > phoPhotonIsolationMap;
  iEvent.getByToken(phoPhotonIsolationToken_, phoPhotonIsolationMap);

  // Get the electron ID data from the event stream.
  // Note: this implies that the VID ID modules have been run upstream.
  edm::Handle<edm::ValueMap<bool> > veto_id_decisions;
  iEvent.getByToken(electronVetoIdMapToken_,veto_id_decisions);
  
  edm::Handle<edm::ValueMap<bool> > medium_id_decisions;
  iEvent.getByToken(electronMediumIdMapToken_,medium_id_decisions);

  edm::Handle<edm::View<pat::Muon> > muonHandle;
  iEvent.getByLabel(muoLabel_,muonHandle);
  const edm::View<pat::Muon> & muons = *muonHandle;   // const ... &, we don't make a copy of it!

  edm::Handle<edm::View<pat::Jet> > jetHandle;
  iEvent.getByLabel(jetLabel_,jetHandle);
  const edm::View<pat::Jet> & jets = *jetHandle;
   
   edm::Handle<edm::View<pat::Electron> > electronHandle;
   iEvent.getByLabel(eleLabel_,electronHandle);
   const edm::View<pat::Electron> & electrons = *electronHandle;
   
   edm::Handle<edm::View<pat::MET> > metHandle;
   iEvent.getByLabel(metLabel_,metHandle);
   const edm::View<pat::MET> & mets = *metHandle;
   
   edm::Handle<edm::View<pat::Photon> > phoHandle;
   iEvent.getByLabel(phoLabel_,phoHandle);
   const edm::View<pat::Photon> & photons = *phoHandle;

   edm::Handle<edm::View<pat::Tau> > tauHandle;
   iEvent.getByLabel(tauLabel_,tauHandle);
   //const edm::View<pat::Tau> & taus = *tauHandle;

   // Swiss cross - ECAL cleaning
   edm::View<pat::Photon>::const_iterator photon;
   Handle<EcalRecHitCollection> Brechit;//barrel
   Handle<EcalRecHitCollection> Erechit;//endcap
   iEvent.getByLabel(rechitBLabel_,Brechit);
   iEvent.getByLabel(rechitELabel_,Erechit);

   edm::ESHandle<CaloTopology> pTopology;
   edm::ESHandle<CaloTopology> theCaloTopo_;
   iSetup.get<CaloTopologyRecord>().get(theCaloTopo_);
   
   // Loop over all objects and evaluate BH properties: ST, mBH, multiplicity ...
   ST=0.;
   
   //Lorentz vectors for jets, egamma, muons, leptons, and all objects
   math::XYZTLorentzVectorF pJet;
   math::XYZTLorentzVectorF pEle;      
   math::XYZTLorentzVectorF pMu;
   math::XYZTLorentzVectorF pPh;
   math::XYZTLorentzVectorF pLep;
   math::XYZTLorentzVectorF pObj;           

   //Beam spot
   math::XYZPoint bs;
       
   // MET
   math::XYZTLorentzVectorF pBH;
   pBH += mets[0].p4();
   Met = mets[0].pt();
   MetPhi = mets[0].phi();
   ST += Met;
   
   MetE = mets[0].energy();
   MetPx = mets[0].px();
   MetPy = mets[0].py();
   MetPz = mets[0].pz();
   MetPt = mets[0].pt();
      
   //Sphericity
   float sumPx2=mets[0].px()*mets[0].px();
   float sumPy2=mets[0].py()*mets[0].py();
   float sumPxPy=mets[0].px()*mets[0].py();   
   
   //Leading objects
   std::vector<double> leadingJets (4,-1);
   std::vector<double> leadingElectrons (4,-1);
   std::vector<double> leadingPhotons (4,-1);
   std::vector<double> leadingMuons (4,-1);
   std::vector<double> leadingObjects (4,-1);
   std::vector<double> leadingLeptons (4,-1);
      
   float leadingElePt = 0;
   float leadingMuPt  = 0;
   float leadingPhPt  = 0;

   int jetcnt         = -1;
   int elecnt         = -1;
   int mucnt          = -1;
   int phcnt          = -1;
   int ngoodmuons     = 0;
   int ngoodphotons   = 0;
   int ngoodelectrons = 0;
   int ngoodjets      = 0;   
   int nPVcount       = 0;
   
   //------ Primary Vertices------- 
   edm::Handle< reco::VertexCollection > PVCollection; 
   iEvent.getByLabel(pvSrc_, PVCollection);
   const reco::Vertex & vertex_ = PVCollection->front();
   //for (reco::VertexCollection::const_iterator vertex_ = PVCollection->begin(); vertex_ != PVCollection->end(); ++vertex_){
   //std::cout<<"Vertex position "<<vertex_->position()<<endl; 
   //}
   
   if (iEvent.getByLabel(pvSrc_, PVCollection )) {
     for (reco::VertexCollection::const_iterator pv = PVCollection->begin(); pv != PVCollection->end(); ++pv) {
       //--- vertex selection
       //std::cout<<" PV "<<pv->x()<<" "<<pv->y()<<" "pv->z()<<std::endl;
       //std::cout<<"PV parameters "<<pv->isFake()<<" "<<fabs(pv->z())<<" "<<pv->position().Rho()<<std::endl;
       //std::cout<<"PV position "<<pv->position()<<endl;
       if (!pv->isFake() && pv->ndof() > 4 && fabs(pv->z()) <= 15. && pv->position().Rho() <= 2.) ++nPVcount;       
     }
   }
   
   // No scraping
   bool noscrap = true;
   
   // HLT results   
   firedHLT_L1Jet6U = false;
   firedHLT_L1Jet10U = false;
   firedHLT_Jet15U = false;
   firedHLT_Jet30U = false;
   firedHLT_Jet50U = false;
   firedHLT_DiJetAve15U_8E29 = false;
   firedHLT_DiJetAve30U_8E29 = false;
   firedHLT_MET45 = false;
   firedHLT_MET100 = false;
   firedHLT_HT100U = false;
   firedHLT_HT140U = false;
   firedHLT_HT140U_Eta3_v1 = false;
   firedHLT_HT160U_v1 = false;
   firedHLT_HT200U = false; 
   firedHLT_FwdJet20U = false;
   firedHLT_QuadJet15U = false;
   firedHLT_L1MET20 = false;
            
   TriggerResults tr;
   Handle<TriggerResults> h_trigRes;
   iEvent.getByLabel(triggerLabel_, h_trigRes);

   tr = *h_trigRes;
  
   std::vector<string> triggerList;
   Service<service::TriggerNamesService> tns;
   bool foundNames = tns->getTrigPaths(tr,triggerList);
   if (!foundNames) std::cout << "Could not get trigger names!\n";
   if (tr.size()!=triggerList.size()) std::cout << "ERROR: length of names and paths not the same: " << triggerList.size() << "," << tr.size() << endl;
   // dump trigger list at first event
   for (unsigned int i=0; i< tr.size(); i++) {
     if ( !tr[i].accept() == 1 ) continue;
     if( triggerList[i] == "HLT_L1Jet6U") { firedHLT_L1Jet6U = true; }
     if( triggerList[i] == "HLT_L1Jet10U") { firedHLT_L1Jet10U = true; }    
     if( triggerList[i] == "HLT_Jet15U") { firedHLT_Jet15U = true; }
     if( triggerList[i] == "HLT_Jet30U") { firedHLT_Jet30U = true; }
     if( triggerList[i] == "HLT_Jet50U") { firedHLT_Jet50U = true; }  
     if( triggerList[i] == "HLT_DiJetAve15U_8E29") { firedHLT_DiJetAve15U_8E29 = true; }   
     if( triggerList[i] == "HLT_DiJetAve30U_8E29") { firedHLT_DiJetAve30U_8E29 = true; }
     if( triggerList[i] == "HLT_MET45") { firedHLT_MET45 = true; }  
     if( triggerList[i] == "HLT_MET100") { firedHLT_MET100 = true; }  
     if( triggerList[i] == "HLT_HT100U") { firedHLT_HT100U = true; }
     if( triggerList[i] == "HLT_HT140U") { firedHLT_HT140U = true; }
     if( triggerList[i] == "HLT_HT140U_Eta3_v1") { firedHLT_HT140U_Eta3_v1 = true; }
     if( triggerList[i] == "HLT_HT160U_v1") { firedHLT_HT160U_v1 = true; }
     if( triggerList[i] == "HLT_HT200U") { firedHLT_HT200U = true; }
     if( triggerList[i] == "HLT_HT200U_v1") { firedHLT_HT200U_v1 = true; }
     if( triggerList[i] == "HLT_FwdJet20U") { firedHLT_FwdJet20U = true; }
     if( triggerList[i] == "HLT_QuadJet15U") { firedHLT_QuadJet15U = true; }
     if( triggerList[i] == "HLT_L1MET20") { firedHLT_L1MET20 = true; }

   }
  
  for(edm::View<pat::Jet>::const_iterator jet = jets.begin(); jet!=jets.end(); ++jet){     
    jetcnt++;  
    
    if(DEBUG_){
      cout <<"jet["<<jetcnt<<"]" <<
      " | n_jets = "<<jets.size()<<
      " | JetID = "<<jetid(jet)<<
      " | pt = "<<jet->pt()<<
      " | eta = "<<fabs(jet->eta())<<
      " | NoD = "<<jet->numberOfDaughters()<<
      " | NHE = "<<jet->neutralHadronEnergyFraction()<<
      " | CHE = "<<jet->chargedHadronEnergyFraction()<<
      " | NEE = "<<jet->neutralEmEnergyFraction()<<
      " | CEE = "<<jet->chargedEmEnergyFraction()<<
      " | ChargedMulti = "<<jet->chargedMultiplicity()<<
      " | "<<endl;
    }
    pBH += jet->p4();
    ST  += jet->et();
    sumPx2 += jet->px()*jet->px();
    sumPy2 += jet->py()*jet->py();
    sumPxPy += jet->px()*jet->py();      
       
    leadingJets.push_back(jet->pt());
    leadingObjects.push_back(jet->pt());

    pJet += jet->p4();
    pObj += jet->p4(); 
         
    JetE[jetcnt]   = jet->energy();
    JetPx[jetcnt]  = jet->px();
    JetPy[jetcnt]  = jet->py();
    JetPz[jetcnt]  = jet->pz();     
    JetPt[jetcnt]  = jet->pt();
    JetEta[jetcnt] = jet->eta();      
    JetPhi[jetcnt] = jet->phi();
    JetNumOfDaughters[jetcnt]       = jet->numberOfDaughters();
    JetNeutralHadEnergyFrac[jetcnt] = jet->neutralHadronEnergyFraction();
    JetChargeHadEnergyFrac[jetcnt]  = jet->chargedHadronEnergyFraction();
    JetNeutralEmEnergyFrac[jetcnt]  = jet->neutralEmEnergyFraction();
    JetChargeEmEnergyFrac[jetcnt]   = jet->chargedEmEnergyFraction();
    JetChargeMult[jetcnt]           = jet->chargedMultiplicity();
    ++ngoodjets;
  }   
   
  for(edm::View<pat::Electron>::const_iterator e = electrons.begin(); e!=electrons.end(); ++e){
    ++elecnt;
   if(!e->gsfTrack()) continue;   
    //smart pointer to pat::Electron
    const Ptr<pat::Electron> elPtr(electronHandle, e - electronHandle->begin() );
    double vtx = fabs(e->gsfTrack()->dxy(vertex_.position()));
    // Rel-isolation with delta beta correction
    reco::GsfElectron::PflowIsolationVariables pfIso = e->pfIsolationVariables();
    double abs_Iso = pfIso.sumChargedHadronPt + std::max(0.0, pfIso.sumNeutralHadronEt + pfIso.sumPhotonEt - 0.5*pfIso.sumPUPt );
    Reliso_el = abs_Iso/e->pt();    
       
   
    if(DEBUG_){  
      cout <<"Ele["<<elecnt<<"]" <<
      " | n_el = "<< electrons.size()<<
      " | eleID = "<<elecId(e,vertex_)<< 
      " | pt = "<<e->pt()<<
      " | eta = "<<fabs(e->eta())<<
      " | vtx_dxy = "<<fabs(e->gsfTrack()->dxy(vertex_.position()))<< 
      " | reliso = "<<Reliso_el<< 
      " | hit = "<<e->gsfTrack()->hitPattern().numberOfHits(reco::HitPattern::MISSING_INNER_HITS)<<
      " | passVetoId = "<<(*veto_id_decisions)[elPtr]<<
      " | passMediumId = "<<(*medium_id_decisions)[elPtr]<<
      " | "<<endl; 
    }

    pBH += e->p4();
    ST  += e->et();
    sumPx2 += e->px()*e->px();
    sumPy2 += e->py()*e->py();
    sumPxPy += e->px()*e->py();
    if (e->pt() > leadingElePt) leadingElePt = e->pt();

    leadingElectrons.push_back(e->pt());
    leadingLeptons.push_back(e->pt());
    leadingObjects.push_back(e->pt());                       

    pEle += e->p4();
    pLep += e->p4();      
    pObj += e->p4(); 


    EleE[elecnt]   = e->energy();
    ElePx[elecnt]  = e->px();
    ElePy[elecnt]  = e->py();
    ElePz[elecnt]  = e->pz();     
    ElePt[elecnt]  = e->pt();
    EleEta[elecnt] = e->eta();      
    ElePhi[elecnt] = e->phi();
    EleSupEta[elecnt] = e->superCluster()->eta();
    ElePassConvVeto[elecnt] = e->passConversionVeto();
    EleChargeHadIso[elecnt] = e->chargedHadronIso();
    EleNeutralHadIso[elecnt] = e->neutralHadronIso();
    ElePhotonIso[elecnt] = e->photonIso();
    EleUsrIso[elecnt] = e->userIsolation("User1Iso");
    EleEt[elecnt] = e->et();
    EleVtx[elecnt] = vtx; 
    EleRelIsoR03DB[elecnt] = pfIso.sumChargedHadronPt+std::max(0.0,pfIso.sumNeutralHadronEt+pfIso.sumPhotonEt-0.5*pfIso.sumPUPt)/e->pt(); 
    EleAbsDxy[elecnt] = fabs(e->gsfTrack()->dxy(vertex_.position()));
    EleVetoId[elecnt] = (*veto_id_decisions)[elPtr];
    EleMediumId[elecnt] = (*medium_id_decisions)[elPtr];
    EleNumOfHits[elecnt] = e->gsfTrack()->hitPattern().numberOfHits(reco::HitPattern::MISSING_INNER_HITS);
    ++ngoodelectrons;
    }  
   // ecal information
   
   // lazyTools_ = std::auto_ptr<EcalClusterLazyTools>( new EcalClusterLazyTools(iEvent,iSetup,ebRecHitsToken_,eeRecHitsToken_) );

   // get ecal barrel recHits for spike rejection
   edm::Handle<EcalRecHitCollection> recHitsEB_h;
   iEvent.getByLabel(ebRecHitsLabel_, recHitsEB_h );
        
         
   //PAT photons     
  for(edm::View<pat::Photon>::const_iterator ph = photons.begin(); ph!=photons.end(); ++ph){
  if (abs(ph->eta()) > 2.4) continue; 
  
  //smart pointer to pat::Photon
  const edm::Ptr<pat::Photon> phoPtr(phoHandle, ph - phoHandle->begin()); 
  ++phcnt;

  
  //isoChargedHadrons, isoNeutralHadrons, isoPhotons with effective area corrections
  int etaBin = 0; 
  while ( etaBin < EffectiveAreas::nEtaBins-1 && abs( ph->superCluster()->eta() ) > EffectiveAreas::etaBinLimits[etaBin+1] )
    { ++etaBin; };
    
    double isoPhotonsWithEA = std::max((float)0.0,(*phoPhotonIsolationMap)[phoPtr]
            -rho_*EffectiveAreas::areaPhotons[etaBin]);
    
    double isoNeutralHadronsWithEA = std::max((float)0.0, (*phoNeutralHadronIsolationMap)[phoPtr]
            -rho_*EffectiveAreas::areaNeutralHadrons[etaBin]);    
    
    double isoChargedHadronsWithEA = std::max((float)0.0,(*phoChargedIsolationMap)[phoPtr] 
            -rho_*EffectiveAreas::areaChargedHadrons[etaBin]);

    if(DEBUG_){  
    cout <<"Pho["<<phcnt<<"]" <<
    " | n_ph = "<< photons.size()<<
    " | PhotID = "<< photonId(ph,vertex_)<<
    " | pt = "<< ph->pt()<<
    " | eta = "<< fabs(ph->superCluster()->eta())<<
    " | phi = " << ph->superCluster()->phi() <<
    " | pix_seed = "<< ph->hasPixelSeed()<<
    " | H/E = "<< ph->hadTowOverEm()<<
    " | Phr9 = "<< ph->userFloat("r9_NoZS") <<
    " | full5x5_sigmaIetaIeta = "<<(*full5x5SigmaIEtaIEtaMap)[phoPtr]<<
    " | passElectronVeto = "<< ph->passElectronVeto()<<
    " | isoChargedHadrons = "<< (*phoChargedIsolationMap)[phoPtr] <<
    " | isoChargedHadronsWithEA = "<< isoChargedHadronsWithEA<<
    " | isoNeutralHadrons = " << (*phoNeutralHadronIsolationMap)[phoPtr]<<
    " | isoNeutralHadronsWithEA = "<< isoNeutralHadronsWithEA<<
    " | isoPhotons = "<< (*phoPhotonIsolationMap)[phoPtr] <<
    " | isoPhotonsWithEA = "<< isoPhotonsWithEA<<
    " | "<<endl;
    }
 
    
  //If not a spike, increment # photons
  ++ngoodphotons;

  pBH += ph->p4();
  ST += ph->et();
  sumPx2 += ph->px()*ph->px();
  sumPy2 += ph->py()*ph->py();
  sumPxPy += ph->px()*ph->py();
  if (ph->pt() > leadingPhPt) leadingPhPt = ph->pt();

  leadingPhotons.push_back(ph->pt());
  leadingObjects.push_back(ph->pt());      

  pPh += ph->p4();    
  pObj += ph->p4();      

  PhE[ngoodphotons-1] = ph->energy();
  PhPx[ngoodphotons-1] = ph->px();
  PhPy[ngoodphotons-1] = ph->py();
  PhPz[ngoodphotons-1] = ph->pz();
  PhPt[ngoodphotons-1] = ph->pt();
  PhEta[ngoodphotons-1] = ph->eta();      
  PhSupEta[ngoodphotons-1] = ph->superCluster()->eta();      
  PhPhi[ngoodphotons-1] = ph->phi();
  PhHadoverEM[ngoodphotons-1] = ph->hadTowOverEm();
  PhHasPixelSeed[ngoodphotons-1] = ph->hasPixelSeed();
  Ph5x5sigmaIetaIeta[ngoodphotons-1] = (*full5x5SigmaIEtaIEtaMap)[phoPtr];
  Phr9[ngoodphotons-1] = ph->userFloat("r9_NoZS");
  
  //isoChargedHadrons, isoNeutralHadrons, isoPhotons without effective area corrections
  PhIsoChargedHadrons[ngoodphotons-1] = (*phoChargedIsolationMap)[phoPtr];
  PhIsoNeutralHadrons[ngoodphotons-1] = (*phoNeutralHadronIsolationMap)[phoPtr];
  PhIsoPhotons[ngoodphotons-1] = (*phoPhotonIsolationMap)[phoPtr];
  
  PhIsoChargedHadronsEA[ngoodphotons-1] = std::max((float)0.0,(*phoChargedIsolationMap)[phoPtr]
              -rho_*EffectiveAreas::areaChargedHadrons[etaBin]);

  PhIsoNeutralHadronsEA[ngoodphotons-1] = std::max((float)0.0, (*phoNeutralHadronIsolationMap)[phoPtr]
              -rho_*EffectiveAreas::areaNeutralHadrons[etaBin]);

  PhIsoPhotonsEA[ngoodphotons-1] = std::max((float)0.0,(*phoPhotonIsolationMap)[phoPtr]
              -rho_*EffectiveAreas::areaPhotons[etaBin]);
  
  //PhSwissCross[ngoodphotons-1] = spikeSelector;
}
  
  for(edm::View<pat::Muon>::const_iterator mu = muons.begin(); mu!=muons.end(); ++mu){
    ++mucnt; 
    
    // Rel-isolation with delta beta correction
    double abs_iso = mu->pfIsolationR04().sumChargedHadronPt+ std::max(0.,mu->pfIsolationR04().sumNeutralHadronEt +
    mu->pfIsolationR04().sumPhotonEt - 0.5*mu->pfIsolationR04().sumPUPt);
    Reliso_mu = abs_iso/mu->pt();

    if(DEBUG_){
      cout <<"Mun["<<mucnt<<"]" <<
      " | n_mu = "<< muons.size()<<
      " | muonID = "<<muonId(mu,vertex_)<<
      " | pt = "<<mu->pt()<<
      " | eta = "<<fabs(mu->eta())<<
      " | fabs(vtx_dxy) = "<<fabs(mu->globalTrack()->dxy(vertex_.position()))<<
      " | reliso = "<<Reliso_mu<<
      " | "<<endl;
    }
    ++ngoodmuons;
     
    pBH += mu->p4();
    ST += mu->et();
    sumPx2 += mu->px()*mu->px();
    sumPy2 += mu->py()*mu->py();
    sumPxPy += mu->px()*mu->py();
    if (mu->pt() > leadingMuPt) leadingMuPt = mu->pt();

    leadingMuons.push_back(mu->pt());
    leadingLeptons.push_back(mu->pt());
    leadingObjects.push_back(mu->pt());

    pMu += mu->p4();
    pLep += mu->p4();      
    pObj += mu->p4(); 

    MuE[ngoodmuons-1] = mu->energy();
    MuPx[ngoodmuons-1] = mu->px();
    MuPy[ngoodmuons-1] = mu->py();
    MuPz[ngoodmuons-1] = mu->pz(); 
    MuPt[ngoodmuons-1] = mu->pt();
    MuEta[ngoodmuons-1] = mu->eta();      
    MuPhi[ngoodmuons-1] = mu->phi(); 
    MuAbsDxy[ngoodmuons-1] = fabs(mu->globalTrack()->dxy(vertex_.position())); 
    MuIsGlobal[ngoodmuons-1] = mu->isGlobalMuon();
    MuIsPF[ngoodmuons-1] = mu->isPFMuon();
    MuNormChi2[ngoodmuons-1] = mu->normChi2();
    MuTrkLayers[ngoodmuons-1] = mu->track()->hitPattern().trackerLayersWithMeasurement();
    MuValidHits[ngoodmuons-1] = mu->globalTrack()->hitPattern().numberOfValidMuonHits();
    MuDz[ngoodmuons-1] = fabs(mu->vertex().z()-(vertex_.z()));
    MuPixelHits[ngoodmuons-1] = mu->innerTrack()->hitPattern().numberOfValidPixelHits();
    MuMatchedStations[ngoodmuons-1] = mu->numberOfMatchedStations();
    MuRelIsoR04DB[ngoodmuons-1] = (mu->pfIsolationR04().sumChargedHadronPt + std::max(0.,mu->pfIsolationR04().sumNeutralHadronEt + mu->pfIsolationR04().sumPhotonEt - 0.5*mu->pfIsolationR04().sumPUPt))/mu->pt(); 
    
    MuRelIsoR03DB[ngoodmuons-1] = (mu->pfIsolationR03().sumChargedHadronPt + std::max(0.,mu->pfIsolationR03().sumNeutralHadronEt + mu->pfIsolationR03().sumPhotonEt - 0.5*mu->pfIsolationR03().sumPUPt))/mu->pt(); 
    }
   
   for (int i=0;i<25;++i) {
     if (i>=ngoodjets) {
       JetE[i]=0.;
       JetPx[i]=0.;
       JetPy[i]=0.;
       JetPz[i]=0.;
       JetPt[i]=0.;
       JetEta[i]=99.;
       JetPhi[i]=99.;
       JetNumOfDaughters[i]=99.;
       JetNeutralHadEnergyFrac[i]=99.;
       JetChargeHadEnergyFrac[i] = 99.;
       JetNeutralEmEnergyFrac[i]=99.;
       JetChargeEmEnergyFrac[i]=99.;
     }
     if (i>=ngoodelectrons) {
       EleE[i]=0.;
       ElePx[i]=0.;
       ElePy[i]=0.;
       ElePz[i]=0.;
       ElePt[i]=0.;
       EleEta[i]=99.;
       ElePhi[i]=99.;
       EleSupEta[i] = 99.;
       EleRelIsoR03DB[i]=99.;
       EleAbsDxy[i]=99.;
       EleVetoId[i]=99.;
       EleMediumId[i]=99.;
       EleNumOfHits[i]=99.;
       ElePassConvVeto[i] = 99.;
       EleChargeHadIso[i] = 0.;
       EleNeutralHadIso[i] = 0.;
       ElePhotonIso[i] = 0.;
       EleUsrIso[i] = 0.;
       EleEt[i] = 0.;
       EleVtx[i] = 0.;
     }
     if (i>=ngoodphotons) {
       PhE[i]=0.;
       PhPx[i]=0.;
       PhPy[i]=0.;
       PhPz[i]=0.;
       PhPt[i]=0.;
       PhEta[i]=99.;
       PhSupEta[i]=99.;
       PhPhi[i]=99.;
       PhHadoverEM[i]=99.;
       PhHasPixelSeed[i]=99.;
       Ph5x5sigmaIetaIeta[i]=99.;
       Phr9[i]=99.;
       
       PhIsoChargedHadrons[i]=99.;
       PhIsoNeutralHadrons[i]=99.;
       PhIsoPhotons[i]=99.;
       
       PhIsoChargedHadronsEA[i]=99.;
       PhIsoNeutralHadronsEA[i]=99.;
       PhIsoPhotonsEA[i]=99.;
       
       PhSwissCross[i]=99.;
     }       
     if (i>=ngoodmuons) {
       MuE[i]=0.;
       MuPx[i]=0.;
       MuPy[i]=0.;
       MuPz[i]=0.;
       MuPt[i]=0.;
       MuEta[i]=99.;
       MuPhi[i]=99.;
       MuAbsDxy[i]=99.;
       MuIsGlobal[i]=99.;
       MuIsPF[i]=99.;
       MuNormChi2[i]=99.;
       MuTrkLayers[i]=99.;
       MuValidHits[i]=99.;
       MuDz[i]=99.;
       MuPixelHits[i]=99.;
       MuMatchedStations[i]=99.;
       MuRelIsoR04DB[i]=99.;
       MuRelIsoR03DB[i]=99.;
     }         
   }
   
   //Sorting
   std::sort(leadingJets.begin(), leadingJets.end());
   std::sort(leadingElectrons.begin(), leadingElectrons.end());
   std::sort(leadingPhotons.begin(), leadingPhotons.end());
   std::sort(leadingMuons.begin(), leadingMuons.end());
   std::sort(leadingLeptons.begin(), leadingLeptons.end());
   std::sort(leadingObjects.begin(), leadingObjects.end());

   std::reverse(leadingJets.begin(), leadingJets.end());
   std::reverse(leadingElectrons.begin(), leadingElectrons.end());
   std::reverse(leadingPhotons.begin(), leadingPhotons.end());
   std::reverse(leadingMuons.begin(), leadingMuons.end());
   std::reverse(leadingLeptons.begin(), leadingLeptons.end());
   std::reverse(leadingObjects.begin(), leadingObjects.end());

   for (int i=0; i<4; ++i){
     JetArr[i] = leadingJets[i];
     EleArr[i] = leadingElectrons[i];
     PhArr[i] = leadingPhotons[i];
     MuArr[i] = leadingMuons[i];
     LeadingArr[i] = leadingObjects[i];
   } 

   float trace = sumPx2 + sumPy2;
   float det = sumPx2*sumPy2 - sumPxPy*sumPxPy;
   float lambda2 = (trace - sqrt(trace*trace - 4*det))/2.0;
   Sphericity = 2*lambda2/trace;
   
   mBH = 0.;
   
   mBH = pBH.M();
   
   //h_norm -> Fill(ST);
   for (size_t i=0; i<cutNames_.size(); ++i){
     std::map<std::string,TH1*>& histo = histos_[i];       
     histo["ST"]->Fill(ST);
   }   
   
   NPV = nPVcount;
   NTracks = 0;
   NJets = ngoodjets;
   NElectrons = ngoodelectrons;
   NMuons = ngoodmuons; 	//not using muons.size() here as |dxy(bs)| < 0.2 might remove cosmics
   NPhotons = ngoodphotons; 	//not using photons.size() here as Swiss cross might remove spikes
   Multiplicity = ngoodjets + ngoodelectrons + ngoodphotons + ngoodmuons;
   
   // Attempts to reduce the size of output file and reject noise and unused events (Mult < 2)
   //if (isMCBH == false && Multiplicity < 2) return;
          
   NoScrap = noscrap; 
   isLeptonPhoton = (ngoodelectrons + ngoodmuons + ngoodphotons > 0);
   
   // Classify event by leading lepton/photon
   isEleChannel = (isLeptonPhoton && (leadingElePt > leadingMuPt) && (leadingElePt > leadingPhPt));
   isMuChannel = (isLeptonPhoton && (leadingMuPt > leadingElePt) && (leadingMuPt > leadingPhPt));
   isPhChannel = (isLeptonPhoton && (leadingPhPt > leadingElePt) && (leadingPhPt > leadingMuPt));
   
   //Filling objects "averaged" angles
   // 99. is the default for angles
   ResJetEta = 99.;
   ResJetPhi = 99.;
   ResEleEta = 99.;
   ResElePhi = 99.;   
   ResPhEta = 99.;
   ResPhPhi = 99.;     
   ResMuEta = 99.;
   ResMuPhi = 99.;
   ResLepEta = 99.;
   ResLepPhi = 99.;      
   ResObjEta = 99.;
   ResObjPhi = 99.; 
    
   if (NJets) {
     ResJetEta = pJet.Eta();
     ResJetPhi = pJet.Phi();
   } else {
     ResJetEta = 99.;
     ResJetPhi = 99.;
   }          
   ResJetM = pJet.M();
   ResJetPt = pJet.Pt();

   if (NElectrons) {
     ResEleEta = pEle.Eta();
     ResElePhi = pEle.Phi();
   } else {
     ResEleEta = 99.;
     ResElePhi = 99.;
   }   
   ResEleM = pEle.M();
   ResElePt = pEle.Pt();
   
   if (NPhotons) {
     ResPhEta = pPh.Eta();
     ResPhPhi = pPh.Phi();
   } else {
     ResPhEta = 99.;
     ResPhPhi = 99.;
   }           
   ResPhM = pPh.M();
   ResPhPt = pPh.Pt();
   
   if (NMuons) {
     ResMuEta = pMu.Eta();
     ResMuPhi = pMu.Phi();
   } else {
     ResMuEta = 99.;
     ResMuPhi = 99.;
   }           
   ResMuM = pMu.M();
   ResMuPt = pMu.Pt();
   
   if (NMuons+NElectrons) {
     ResLepEta = pLep.Eta();
     ResLepPhi = pLep.Phi();
   } else {
     ResLepEta = 99.;
     ResLepPhi = 99.;
   }       
   ResLepM = pLep.M();
   ResLepPt = pLep.Pt();
   
   if (NMuons+NElectrons+NPhotons+NJets) {
     ResObjEta = pObj.Eta();
     ResObjPhi = pObj.Phi();
   } else {
     ResObjEta = 99.;
     ResObjPhi = 99.;
   }     
   ResObjM = pObj.M();
   ResObjPt = pObj.Pt();
   
   tree->Fill();

}


// ------------ method called once each job just before starting event loop  ------------
void BHAnalyzerTLBSM::beginJob()
{
  cutNames_.push_back("No_Cut");
  
  tree = fs_->make<TTree>("t","t");
  //h_norm = new TH1F("h_norm","",500,0,50000);

  tree->Branch("NJets",&NJets,"NJets/I");
  tree->Branch("JetE",&JetE,"JetE[NJets]");
  tree->Branch("JetPx",&JetPx,"JetPx[NJets]");
  tree->Branch("JetPy",&JetPy,"JetPy[NJets]");
  tree->Branch("JetPz",&JetPz,"JetPz[NJets]");
  tree->Branch("JetPt",&JetPt,"JetPt[NJets]");
  tree->Branch("JetEta",&JetEta,"JetEta[NJets]");
  tree->Branch("JetPhi",&JetPhi,"JetPhi[NJets]");
  tree->Branch("JetNumOfDaughters",&JetNumOfDaughters,"JetNumOfDaughters[NJets]");
  tree->Branch("JetNeutralHadEnergyFrac",&JetNeutralHadEnergyFrac,"JetNeutralHadEnergyFrac[NJets]");
  tree->Branch("JetChargeHadEnergyFrac", &JetChargeHadEnergyFrac, "JetChargeHadEnergyFrac[NJets]");
  tree->Branch("JetNeutralEmEnergyFrac",&JetNeutralEmEnergyFrac,"JetNeutralEmEnergyFrac[NJets]");
  tree->Branch("JetChargeEmEnergyFrac",&JetChargeEmEnergyFrac,"JetChargeEmEnergyFrac[NJets]");
  tree->Branch("JetChargeMult", &JetChargeMult, "JetChargeMult[NJets]");

  tree->Branch("EleE",&EleE,"EleE[25]");
  tree->Branch("ElePx",&ElePx,"ElePx[25]");
  tree->Branch("ElePy",&ElePy,"ElePy[25]");
  tree->Branch("ElePz",&ElePz,"ElePz[25]");
  tree->Branch("ElePt",&ElePt,"ElePt[25]");
  tree->Branch("EleEta",&EleEta,"EleEta[25]");
  tree->Branch("ElePhi",&ElePhi,"ElePhi[25]");
  tree->Branch("EleSupEta", &EleSupEta, "EleSupEta[25]");
  tree->Branch("EleRelIsoR03DB",&EleRelIsoR03DB,"EleRelIsoR03DB[25]");
  tree->Branch("EleAbsDxy",&EleAbsDxy,"EleAbsDxy[25]");
  tree->Branch("EleVetoId",&EleVetoId,"EleVetoId[25]");
  tree->Branch("EleMediumId",&EleMediumId,"EleMediumId[25]");
  tree->Branch("EleNumOfHits",&EleNumOfHits,"EleNumOfHits[25]");
  tree->Branch("ElePassConvVeto", &ElePassConvVeto, "ElePassConvVeto[25]");
  tree->Branch("EleChargeHadIso", &EleChargeHadIso, "EleChargeHadIso[25]");
  tree->Branch("EleNeutralHadIso", &EleNeutralHadIso, "EleNeutralHadIso[25]");
  tree->Branch("ElePhotonIso", &ElePhotonIso, "ElePhotonIso[25]");
  tree->Branch("EleUsrIso", &EleUsrIso, "EleUsrIso[25]");
  tree->Branch("EleEt", &EleEt, "EleEt[25]");
  tree->Branch("EleVtx", &EleVtx, "EleVtx[25]"); 
 
  tree->Branch("PhE",&PhE,"PhE[25]");
  tree->Branch("PhPx",&PhPx,"PhPx[25]");
  tree->Branch("PhPy",&PhPy,"PhPy[25]");
  tree->Branch("PhPz",&PhPz,"PhPz[25]");
  tree->Branch("PhPt",&PhPt,"PhPt[25]");
  tree->Branch("PhEta",&PhEta,"PhEta[25]");
  tree->Branch("PhSupEta",&PhSupEta,"PhSupEta[25]");
  tree->Branch("PhPhi",&PhPhi,"PhPhi[25]");
  tree->Branch("PhSwissCross",&PhSwissCross,"PhSwissCross[25]");  
  tree->Branch("PhHadoverEM",&PhHadoverEM,"PhHadoverEM[25]");
  tree->Branch("PhHasPixelSeed",&PhHasPixelSeed,"PhHasPixelSeed[25]");
  tree->Branch("Ph5x5sigmaIetaIeta",&Ph5x5sigmaIetaIeta,"Ph5x5sigmaIetaIeta[25]");
  tree->Branch("Phr9",&Phr9,"Phr9[25]");
  
  tree->Branch("PhIsoChargedHadrons",&PhIsoChargedHadrons,"PhIsoChargedHadrons[25]");
  tree->Branch("PhIsoNeutralHadrons",&PhIsoNeutralHadrons,"PhIsoNeutralHadrons[25]");
  tree->Branch("PhIsoPhotons",&PhIsoPhotons,"PhIsoPhotons[25]");
  
  tree->Branch("PhIsoChargedHadronsEA",&PhIsoChargedHadronsEA,"PhIsoChargedHadronsEA[25]");
  tree->Branch("PhIsoNeutralHadronsEA",&PhIsoNeutralHadronsEA,"PhIsoNeutralHadronsEA[25]");
  tree->Branch("PhIsoPhotonsEA",&PhIsoPhotonsEA,"PhIsoPhotonsEA[25]");

  tree->Branch("MuE",&MuE,"MuE[25]");
  tree->Branch("MuPx",&MuPx,"MuPx[25]");
  tree->Branch("MuPy",&MuPy,"MuPy[25]");
  tree->Branch("MuPz",&MuPz,"MuPz[25]");
  tree->Branch("MuPt",&MuPt,"MuPt[25]");
  tree->Branch("MuEta",&MuEta,"MuEta[25]");
  tree->Branch("MuPhi",&MuPhi,"MuPhi[25]");
  tree->Branch("MuAbsDxy",&MuAbsDxy,"MuAbsDxy[25]");  
  tree->Branch("MuIsGlobal",&MuIsGlobal,"MuIsGlobal[25]");  
  tree->Branch("MuIsPF",&MuIsPF,"MuIsPF[25]");  
  tree->Branch("MuNormChi2",&MuNormChi2,"MuNormChi2[25]");  
  tree->Branch("MuTrkLayers",&MuTrkLayers,"MuTrkLayers[25]");  
  tree->Branch("MuValidHits",&MuValidHits,"MuValidHits[25]");  
  tree->Branch("MuDz",&MuDz,"MuDz[25]");  
  tree->Branch("MuPixelHits",&MuPixelHits,"MuPixelHits[25]");  
  tree->Branch("MuMatchedStations",&MuMatchedStations,"MuMatchedStations[25]");  
  tree->Branch("MuRelIsoR04DB",&MuRelIsoR04DB,"MuRelIsoR04DB[25]");  
  tree->Branch("MuRelIsoR03DB",&MuRelIsoR03DB,"MuRelIsoR03DB[25]");  
    
  tree->Branch("ST",&ST,"ST/F");
  tree->Branch("mBH",&mBH,"mBH/F");
  tree->Branch("Met",&Met,"Met/F");
  tree->Branch("MetE",&MetE,"MetE/F");
  tree->Branch("MetPx",&MetPx,"MetPx/F");
  tree->Branch("MetPy",&MetPy,"MetPy/F");
  tree->Branch("MetPz",&MetPz,"MetPz/F");
  tree->Branch("MetPt",&MetPt,"MetPt/F");
  tree->Branch("MetPhi",&MetPhi,"MetPhi/F");   
  tree->Branch("Sphericity", &Sphericity, "Sphericity/F");
  tree->Branch("Jet",JetArr,"JetArr[4]");   
  tree->Branch("Ele",EleArr,"EleArr[4]");
  tree->Branch("Mu",MuArr,"MuArr[4]");
  tree->Branch("Ph",PhArr,"PhArr[4]");   
  tree->Branch("NPV",&NPV,"NPV/I");   
  tree->Branch("NTracks",&NTracks,"NTracks/I");   
  tree->Branch("NElectrons",&NElectrons,"NElectrons/I");
  tree->Branch("NPhotons",&NPhotons,"NPhotons/I");
  tree->Branch("NMuons",&NMuons,"NMuons/I");
  tree->Branch("NoScrap", &NoScrap, "NoScrap/B");     
  
  tree->Branch("Multiplicity", &Multiplicity, "Multiplicity/I");
  tree->Branch("isLeptonPhoton", &isLeptonPhoton, "isLeptonPhoton/B");   
  tree->Branch("isEleChannel", &isEleChannel, "isEleChannel/B");
  tree->Branch("isMuChannel", &isMuChannel, "isMuChannel/B"); 
  tree->Branch("isPhChannel", &isPhChannel, "isPhChannel/B");
  
  tree->Branch("ResJetEta",&ResJetEta,"ResJetEta/F"); 
  tree->Branch("ResJetPhi",&ResJetPhi,"ResJetPhi/F");
  tree->Branch("ResJetM",&ResJetM,"ResJetM/F");
  tree->Branch("ResJetPt",&ResJetPt,"ResJetPt/F");
  tree->Branch("ResEleEta",&ResEleEta,"ResEleEta/F"); 
  tree->Branch("ResElePhi",&ResElePhi,"ResElePhi/F");
  tree->Branch("ResEleM",&ResEleM,"ResEleM/F");
  tree->Branch("ResElePt",&ResElePt,"ResElePt/F");  
  tree->Branch("ResPhEta",&ResPhEta,"ResPhEta/F"); 
  tree->Branch("ResPhPhi",&ResPhPhi,"ResPhPhi/F");
  tree->Branch("ResPhM",&ResPhM,"ResPhM/F");
  tree->Branch("ResPhPt",&ResPhPt,"ResPhPt/F");   
  tree->Branch("ResMuEta",&ResMuEta,"ResMuEta/F"); 
  tree->Branch("ResMuPhi",&ResMuPhi,"ResMuPhi/F");
  tree->Branch("ResMuM",&ResMuM,"ResMuM/F");
  tree->Branch("ResMuPt",&ResMuPt,"ResMuPt/F");
  tree->Branch("ResLepEta",&ResLepEta,"ResLepEta/F"); 
  tree->Branch("ResLepPhi",&ResLepPhi,"ResLepPhi/F");
  tree->Branch("ResLepM",&ResLepM,"ResLepM/F");
  tree->Branch("ResLepPt",&ResLepPt,"ResLepPt/F");   
  tree->Branch("ResObjEta",&ResObjEta,"ResObjEta/F"); 
  tree->Branch("ResObjPhi",&ResObjPhi,"ResObjPhi/F");
  tree->Branch("ResObjM",&ResObjM,"ResObjM/F");
  tree->Branch("ResObjPt",&ResObjPt,"ResObjPt/F"); 
  
  tree->Branch("runno",&runno,"runno/I");
  tree->Branch("evtno",&evtno,"evtno/I"); 
  tree->Branch("lumiblock",&lumiblock,"lumiblock/I");               
  tree->Branch("isRealData",&isRealData,"isRealData/I");
  tree->Branch("muon_d0",&muon_d0,"muon_d0/F");                                                      
  
  tree->Branch("firedHLT_L1Jet6U",&firedHLT_L1Jet6U,"firedHLT_L1Jet6U/B");
  tree->Branch("firedHLT_L1Jet10U",&firedHLT_L1Jet10U,"firedHLT_L1Jet10U/B");
  tree->Branch("firedHLT_Jet15U",&firedHLT_Jet15U,"firedHLT_Jet15U/B");
  tree->Branch("firedHLT_Jet30U",&firedHLT_Jet30U,"firedHLT_Jet30U/B");
  tree->Branch("firedHLT_Jet50U",&firedHLT_Jet50U,"firedHLT_Jet50U/B");
  tree->Branch("firedHLT_DiJetAve15U_8E29",&firedHLT_DiJetAve15U_8E29,"firedHLT_DiJetAve15U_8E29/B");
  tree->Branch("firedHLT_DiJetAve30U_8E29",&firedHLT_DiJetAve30U_8E29,"firedHLT_DiJetAve30U_8E29/B");
  tree->Branch("firedHLT_MET45",&firedHLT_MET45,"firedHLT_MET45/B");
  tree->Branch("firedHLT_MET100",&firedHLT_MET100,"firedHLT_MET100/B");
  tree->Branch("firedHLT_HT100U",&firedHLT_HT100U,"firedHLT_HT100U/B");  
  tree->Branch("firedHLT_HT140U",&firedHLT_HT140U,"firedHLT_HT140U/B");
  tree->Branch("firedHLT_HT140U_Eta3_v1",&firedHLT_HT140U_Eta3_v1,"firedHLT_HT140U_Eta3_v1/B");
  tree->Branch("firedHLT_HT160U_v1",&firedHLT_HT160U_v1,"firedHLT_HT160U_v1/B");
  tree->Branch("firedHLT_HT200U",&firedHLT_HT200U,"firedHLT_HT200U/B");
  tree->Branch("firedHLT_HT200U_v1",&firedHLT_HT200U_v1,"firedHLT_HT200U_v1/B");
  tree->Branch("firedHLT_FwdJet20U",&firedHLT_FwdJet20U,"firedHLT_FwdJet20U/B");
  tree->Branch("firedHLT_QuadJet15U",&firedHLT_QuadJet15U,"firedHLT_QuadJet15U/B");
  tree->Branch("firedHLT_L1MET20",&firedHLT_L1MET20,"firedHLT_L1MET20/B");
    
  for (size_t i=0; i<cutNames_.size(); ++i)
    createHistogram(cutNames_[i]);
  
}

void BHAnalyzerTLBSM::createHistogram(const std::string& folderName){
  TFileDirectory subDir = fs_->mkdir(folderName);
  std::map<std::string, TH1*> container;
  
  container["ST"] = subDir.make<TH1F>("ST", "ST", 500, 0, 100000);
  
  histos_.push_back(container);          
}

bool BHAnalyzerTLBSM::check(std::string process, std::string pCheck) {
  bool value= false;
  
  if (process == pCheck) value = true;
  
  return value;
}


//JetID 
bool BHAnalyzerTLBSM::jetid(const edm::View<pat::Jet>::const_iterator &jet_iter){
  if(jet_iter->pt() < 20) return false;
  if(fabs(jet_iter->eta()) > 2.6) return false;
  if(jet_iter->numberOfDaughters() < 1) return false;
  if(jet_iter->neutralHadronEnergyFraction() > 0.99) return false;
  if(jet_iter->neutralEmEnergyFraction() > 0.99) return false;
  
  if(abs(jet_iter->eta()) < 2.4 ){
    if(jet_iter->chargedHadronEnergyFraction() < 0) return false;
    if(jet_iter->chargedMultiplicity() < 0) return false;
    if(jet_iter->chargedEmEnergyFraction() > 0.99) return false;
    }
  return true;
  }

  //Electron ID
  bool BHAnalyzerTLBSM::elecId(const edm::View<pat::Electron>::const_iterator &elec_iter, const reco::Vertex & vertex_){
  if(!elec_iter->gsfTrack()) return false;  //is GsfElectron // or check!! if(!elec_iter->isPF()) return false;
  if(elec_iter->pt() < 20) return false;
  if(fabs(elec_iter->eta()) > 2.5) return false;
  if(elec_iter->electronID(eleID_medium.encode())< 0.5) return false;
  if(elec_iter->passConversionVeto()==false) return false;
  if(fabs(elec_iter->superCluster()->eta())>1.4442 && fabs(elec_iter->superCluster()->eta())<1.5660) return false;
  
  //Transverse IP of the elecrtron (GSF track) w.r.t. the first offline primary 
  if(fabs(elec_iter->gsfTrack()->dxy(vertex_.position())) > 0.04) return false;

  //if(elec_iter->gsfTrack()->trackerExpectedHitsInner().numberOfHits() >=0 ) return false; Change due the file size
  //when writing Hit pattern https://twiki.cern.ch/twiki/bin/view/CMS/TrackingHitPatternRedesign
  if(elec_iter->gsfTrack()->hitPattern().numberOfHits(reco::HitPattern::MISSING_INNER_HITS) > 0) return false;

  //RelIsolation with Delta beta corrections, the isolation variables use the standard recommended cone size =0.3
  reco::GsfElectron::PflowIsolationVariables pfIso = elec_iter->pfIsolationVariables();
  double abs_Iso = pfIso.sumChargedHadronPt + std::max(0.0, pfIso.sumNeutralHadronEt + pfIso.sumPhotonEt - 0.5*pfIso.sumPUPt );
  Reliso_el = abs_Iso/elec_iter->pt();
  
  if(Reliso_el >= 0.20) return false;
  return true;
  }


//Muon ID https://twiki.cern.ch/twiki/bin/view/CMS/TopMUO
bool BHAnalyzerTLBSM::muonId(const edm::View<pat::Muon>::const_iterator &muon_iter, const reco::Vertex & vertex_){
  if(!(muon_iter->isGlobalMuon())) return false;
  if(!muon_iter->isPFMuon()) return false;
  if(muon_iter->normChi2() > 10.) return false;
  if(muon_iter->track()->hitPattern().trackerLayersWithMeasurement()<5) return false;
  if(muon_iter->globalTrack()->hitPattern().numberOfValidMuonHits()<0) return false;
  if(fabs(muon_iter->globalTrack()->dxy(vertex_.position()))>0.2) return false;
  if(fabs(muon_iter->vertex().z()-(vertex_.z()))>0.5) return false;
  if(muon_iter->innerTrack()->hitPattern().numberOfValidPixelHits()<0) return false;
  if(muon_iter->numberOfMatchedStations()<1)return false;

  //muon reliso delta beta corrections for R = 0.4 
  double abs_iso = muon_iter->pfIsolationR04().sumChargedHadronPt+ std::max(0.,muon_iter->pfIsolationR04().sumNeutralHadronEt + 
  muon_iter->pfIsolationR04().sumPhotonEt - 0.5*muon_iter->pfIsolationR04().sumPUPt);
  Reliso_mu = abs_iso/muon_iter->pt();

  if(Reliso_mu >= 0.20) return false;
  if(muon_iter->pt() < 20) return false;
  if(muon_iter->eta() > 2.4) return false;
  return true;
  }


//PhotonID 
bool BHAnalyzerTLBSM::photonId(const edm::View<pat::Photon>::const_iterator & ph_iter, const reco::Vertex & vertex_){
  if(ph_iter->hasPixelSeed()) return false;
  if(ph_iter->hadronicOverEm()> 0.05) return false;
  if(fabs(ph_iter->superCluster()->eta()) > 1.4442 && ph_iter->sigmaIetaIeta() > 0.011) return false;
  if(fabs(ph_iter->superCluster()->eta()) < 1.5660 && fabs(ph_iter->superCluster()->eta()) > 2.5 
    && ph_iter->sigmaIetaIeta() > 0.038) return false;
  
  return true;
}
// ------------ method called once each job just after ending the event loop  ------------
void BHAnalyzerTLBSM::endJob() {
  //h_norm->Write();
}


//define this as a plug-in
DEFINE_FWK_MODULE(BHAnalyzerTLBSM);
